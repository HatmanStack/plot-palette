"""
Plot Palette - Test Template Lambda Handler

POST /templates/{template_id}/test endpoint that allows dry-run testing
of templates with sample data.
"""

import json
import os
import sys
from typing import Any, Dict

# Add shared library to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../shared'))

import boto3
from botocore.exceptions import ClientError

from utils import setup_logger, get_nested_field

# Initialize logger
logger = setup_logger(__name__)

# Initialize AWS clients
dynamodb = boto3.resource('dynamodb')
templates_table = dynamodb.Table(os.environ.get('TEMPLATES_TABLE_NAME', 'plot-palette-Templates'))

# Bedrock client (only initialized if needed)
bedrock_client = None


def get_bedrock_client():
    """Lazy initialization of Bedrock client."""
    global bedrock_client
    if bedrock_client is None:
        bedrock_client = boto3.client('bedrock-runtime')
    return bedrock_client


def execute_template_mock(template_def: Dict, seed_data: Dict) -> Dict:
    """
    Execute template with mocked Bedrock responses (no actual API calls).

    Args:
        template_def: Template definition dictionary
        seed_data: Sample data for template variables

    Returns:
        Dict: Results for each step with mocked outputs
    """
    # Import TemplateEngine
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../ecs_tasks/worker'))
    from template_engine import TemplateEngine

    engine = TemplateEngine()
    results = {}
    context = seed_data.copy()

    for step in template_def.get('steps', []):
        step_id = step['id']
        model_id = step.get('model', step.get('model_tier', 'tier-1'))

        try:
            # Render prompt with context
            prompt = engine.render_step(step, context)

            # Generate mock output
            mock_output = f"[MOCK OUTPUT for step '{step_id}']\n\n"
            mock_output += f"Model: {model_id}\n"
            mock_output += f"This is a simulated response. In production, this would be generated by AWS Bedrock.\n"
            mock_output += f"\nPrompt preview: {prompt[:200]}..."

            results[step_id] = {
                'prompt': prompt,
                'output': mock_output,
                'model': model_id,
                'mocked': True,
                'prompt_length': len(prompt),
                'prompt_tokens_estimate': len(prompt) // 4
            }

            # Add to context for next steps
            if 'steps' not in context:
                context['steps'] = {}
            if step_id not in context['steps']:
                context['steps'][step_id] = {}
            context['steps'][step_id]['output'] = mock_output

        except Exception as e:
            logger.error(f"Error in mock execution for step '{step_id}': {str(e)}", exc_info=True)
            results[step_id] = {
                'error': str(e),
                'model': model_id,
                'mocked': True
            }

    return results


def execute_template_real(template_def: Dict, seed_data: Dict) -> Dict:
    """
    Execute template with real Bedrock API calls.

    Args:
        template_def: Template definition dictionary
        seed_data: Sample data for template variables

    Returns:
        Dict: Results for each step with real outputs
    """
    # Import TemplateEngine
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../ecs_tasks/worker'))
    from template_engine import TemplateEngine

    try:
        engine = TemplateEngine(dynamodb_client=dynamodb)
        bedrock = get_bedrock_client()
        results = engine.execute_template(template_def, seed_data, bedrock)

        # Add metadata
        for step_id, step_result in results.items():
            step_result['mocked'] = False
            if 'prompt' in step_result:
                step_result['prompt_length'] = len(step_result['prompt'])
                step_result['prompt_tokens_estimate'] = len(step_result['prompt']) // 4

        return results

    except Exception as e:
        logger.error(f"Error in real execution: {str(e)}", exc_info=True)
        raise


def error_response(status_code: int, message: str) -> Dict[str, Any]:
    """Generate error response."""
    return {
        "statusCode": status_code,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*"
        },
        "body": json.dumps({"error": message})
    }


def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Lambda handler for POST /templates/{template_id}/test endpoint.

    Allows testing templates with sample data before creating full jobs.

    Args:
        event: API Gateway event
        context: Lambda context

    Returns:
        Dict: API Gateway response with test results
    """
    try:
        # Extract user ID from JWT claims
        user_id = event['requestContext']['authorizer']['jwt']['claims']['sub']
        template_id = event['pathParameters']['template_id']

        logger.info(json.dumps({
            "event": "test_template_request",
            "user_id": user_id,
            "template_id": template_id
        }))

        # Parse request body
        try:
            body = json.loads(event['body'])
        except json.JSONDecodeError:
            return error_response(400, "Invalid JSON in request body")

        sample_data = body.get('sample_data', {})
        use_mock = body.get('mock', True)  # Default to mock to avoid costs

        # Get template from DynamoDB
        try:
            response = templates_table.get_item(
                Key={'template_id': template_id, 'version': 1}
            )
        except ClientError as e:
            logger.error(f"DynamoDB error: {str(e)}")
            return error_response(500, "Error retrieving template")

        if 'Item' not in response:
            return error_response(404, "Template not found")

        template = response['Item']

        # Check ownership or public access
        if template['user_id'] != user_id and not template.get('is_public', False):
            return error_response(403, "Access denied to this template")

        # Validate sample data has required fields
        schema_reqs = template.get('schema_requirements', [])
        missing_fields = []

        for field in schema_reqs:
            # Check explicitly for None to allow falsy values like 0, False, '', []
            if get_nested_field(sample_data, field) is None:
                missing_fields.append(field)

        if missing_fields:
            return error_response(
                400,
                f"Missing required fields in sample_data: {', '.join(missing_fields)}"
            )

        # Execute template
        template_def = template['template_definition']

        if use_mock:
            logger.info("Executing template in mock mode")
            result = execute_template_mock(template_def, sample_data)
        else:
            logger.info("Executing template with real Bedrock calls")
            result = execute_template_real(template_def, sample_data)

        logger.info(json.dumps({
            "event": "test_template_complete",
            "template_id": template_id,
            "steps_executed": len(result),
            "mock": use_mock
        }))

        return {
            "statusCode": 200,
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            },
            "body": json.dumps({
                "template_id": template_id,
                "template_name": template['name'],
                "sample_data": sample_data,
                "result": result,
                "mock": use_mock,
                "steps_count": len(result),
                "message": "Template test completed successfully"
            })
        }

    except KeyError as e:
        logger.error(f"Missing field: {str(e)}", exc_info=True)
        return error_response(400, f"Missing required field: {str(e)}")

    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        return error_response(500, "Internal server error")
